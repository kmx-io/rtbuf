RTBUF 0.2 - real time buffers

Minimalist framework for real time signal processing in C.

RTBUF is a modular system : you write real time functions in C
in a library. You can then load these libraries and instanciate
real-time functions into buffers which are bound to one another.

New data types can be statically defined in libraries.
Enough memory is pre-allocated for all functions according to
their variable and output declarations. All memory is pre-allocated
using libdata : https://github.com/kmx-io/libdata .

A minimalistic command line using readline is provided through CLI :
https://github.com/kmx-io/cli . The system can be inspected, modified,
rewired, new buffers can be created, bound and deleted, etc.
all while the system is running. A simple REPL provides a few
predefined commands which you can learn about by using the "help"
command.

A real time function is made of :
 - a name (a string identifier)
 - an optional start method that will be called before computation
   starts
 - an optional compute method that will be called in real time to
   produce the buffer outputs according to variables and their bindings.
 - an optional stop method that will be called after computation
   finishes
 - variable definitions which are made of a name and a type designator
 - output definitions which are made of a name and a type designator

Your library has to export specific symbols :
  rtbuf_lib_name  the name of your library
  rtbuf_lib_ver   set to RTBUF_LIB_VER to verify compatiblity
  rtbuf_lib_fun   an array of library function definitions

Optional symbols :
  rtbuf_lib_init  a function to initialize the library

When creating a new buffer from a real time function the outputs are
allocated into buffer->data. Under the hood libdata is used to
pre-allocate all data in real-time fashion.

The buffers are ordered according to bindings and real time computation
can start. For each tick all buffers are computed. Default settings
have one tick for two milliseconds (which is kinda short if your
computer is slow and might jitter a lot depending on system load).

There are multiple libraries for RTBUF already under development and
distributed along with RTBUF :
  RTBUF dynamic - Dynamic range signal processing.
  RTBUF glfw3   - Portable OpenGL, keyboard and mouse library.
  RTBUF music   - Music functions.
  RTBUF signal  - Signal processing, operations on buffers of doubles.
  RTBUF sndio   - OpenBSD sndio library for hardware audio i/o.
  RTBUF synth   - A synthesizer collection.

If you would like to improve on existing libraries or come up with
your own please get into contact ASAP.

Coming soon :
 - PortAudio hardware audio i/o. (feeling alone on OpenBSD ^^)
 - timing of functions for measuring resource usage
 - rethink library defined data types, allocators and accessors
 - have the buffers allocate and access memory using libdata.
   Somehow we need practical memory usage limits for all defined
   data types. I really do not know how to have all the memory limits
   making sense for all possible purposes of RTBUF. But heck, nowadays
   memory is cheap and should not be considered a hard problem.
 - compute the buffer outputs lazily, which would greatly reduce the
   computation load in many situations. It involves chanelling all
   buffer output access function calls through a lazily computed data
   query system. It might remove the need for sorting buffers. So
   there is much room for performance improvements though it is already
   quite fast.
 - wrappers for existing digital signal processing standards :
   LADSPA, DSSI, LV2 (simple and open source, from the Linux crowd)
   VST, audio units, RTAS, AAX, DirectX plugins, DMO, MFT. (commercial)
